---
layout: post
title:  "数据库-隔离级别"
date:   2018-08-22 18:51:31 +0800
categories: 数据库
tags: 行级锁 隔离级别
---

* content
{:toc}

## 1.隔离级别
### 读未提交 read uncommited
会造成脏读，即一个事务读取另外一个事务还没有提交的数据。
原因：事务T1修改了一行数据，但是还没有提交，这时候事务T2读取了被事务T1修改后的数据，之后事务T1因为某种原因Rollback了，那么事务T2读取的数据就是脏的。
Oracle默认的隔离级别是【读提交】（read commited）,MySQL 默认的隔离级别是  【可重复读】（repeatable read）

### 读已提交 read committed
会造成不可重复读，即在同一个事务内，两个相同的查询返回了不同的结果。
原因：事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，便得到了不同的结果。

### 可重复读 repeaetable read
以操作同一行数据为前提，读事务禁止其他写事务（但允许其他读事务），未提交的写事务禁止其他读事务和写事务。
此隔离级别可以防止更新丢失、脏读、不可重复读，但不能防止幻读。
此隔离级别可以通过“共享读锁”和“排他写锁”实现。

### 串行化 Serializable
提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。

此隔离级别可以防止更新丢失、脏读、不可重复读、幻读。

参考博客：<br>
[CSDN三、数据库由于并发事务而引起的问题以及事务的隔离级别][1] <br>
[CSDN四、数据库锁机制--行级锁（悲观锁与乐观锁）与表级锁][2]


  [1]: https://blog.csdn.net/qq_32317661/article/details/80468778
  [2]: https://blog.csdn.net/qq_32317661/article/details/80486102