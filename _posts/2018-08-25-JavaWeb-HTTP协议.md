---
layout: post
title:  "JavaWeb-HTTP协议"
date:   2018-08-25 10:44:31 +0800
categories: JavaWeb
tags: http
---

* content
{:toc}

## Http请求与响应
由浏览器向服务器发送数据，称为请求Request。由服务器向浏览器发送数据，则称为响应Response。那么，什么才是浏览器向服务器发送的请求呢？在浏览器地址栏中通过地址访问是最典型的请求方式，另外还有点击表单的提交按钮、点击超链接、发送 AJAX 请求。
```
// TODO 那么还有其它形式的请求吗？
```

## 怎么理解http是无状态的网络协议
参考博文
[http协议无状态中的"状态"到底指的是什么？！][1]
[http协议和web应用有状态和无状态浅析][2]


## HTTP版本
### HTTP1.0 版本
HTTP1.0 协议中的连接属于非持久连接，且服务器不跟踪和记录任何一次请求与响应。
![http1.0][3]

### HTTP1.1 版本
HTTP 1.1 版本是目前浏览器默认采用的HTTP协议版本，是一种持久连接，在一个TCP连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。一个包含有许多CSS、JS、图片等资源的页面，其所发出的多个请求和响应可以在一个连接中传输。**但每个单独的页面文件的请求和响应仍然需要使用各自的连接。**

HTTP1.0 在客户端接收到服务端发送来的响应后，TCP 连接马上关闭。而HTTP1.1的连接是什么时候关闭呢？客户端在发送创建TCP连接请求之前首先计算出本次连接浏览器所要发送的请求数量，即一次手工请求加上其所携带的所有自动请求数量。**当所有浏览器所发出的请求全部发送完毕后，客户端会再自动发送一个关闭TCP连接的请求。这个请求在HttpWatch 中是看不到的。**（通过请求头的`connecton`参数控制， `keep-alive`, `close`）
![http1.1][4]

### HTTP1.0 与 HTTP1.1 版本的对比
#### HTTP1.0
 - HTTP1.0 协议中的连接属于非持久连接，一次 TCP 连接只能进行一次请求与响应。一次请求与响应对应一个 TCP 连接。
 - 客户端只有在接收到服务端对上一次请求的响应后，客户端才可发出第二次请求。
 - HTTP1.0 不支持对虚拟主机的访问。因为其没有 HOST 请求头属性，会将用户所发出的域名直接通过 DNS 转换为 IP后，发送到服务端。也就是说，服务端接收到的直接就是个 IP 而非域名。这样HTTP1.0 的请求就不支持对虚拟主机的访问了。
 - HTTP1.0 协议中在客户端接收到服务端的响应后，马上发送关闭TCP连接的请求，服务端关闭连接。

#### HTTP1.1
 - HTTP 1.1 支持持久连接，在一个TCP连接上可以传送多个请求和响应。
 - 一般情况下，一个页面中的请求与响应对应一个 TCP 连接。
 - HTTP 1.1 还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求。
 - HTTP1.1 支持对虚拟主机的访问。其在请求头属性中增加了`HOST`属性，用于记录请求所要访问的虚拟域名。当然，请求中所携带的域名，肯定会通过 DNS 将其转换为IP，然后查找到相应的主机。但由于请求中还携带有`HOST`属性，即要访问的域名仍然在请求中，这样的话，服务器就可以从请求中解析出请求所要访问的虚拟主机名。
 - HTTP1.1 协议中在客户端接收到对最后一次请求的响应后，马上发送关闭TCP连接请求，服务端关闭连接。

## HTTP状态码
 > 状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:
1xx：指示信息--表示请求已接收，继续处理
2xx：成功--表示请求已被成功接收、理解、接受
3xx：重定向--要完成请求必须进行更进一步的操作
4xx：客户端错误--请求有语法错误或请求无法实现
5xx：服务器端错误--服务器未能实现合法的请求


常见状态码：
 > 200 OK   //客户端请求成功
400 Bad Request  //客户端请求有语法错误，不能被服务器所理解
401 Unauthorized  //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 
403 Forbidden  //服务器收到请求，但是拒绝提供服务
404 Not Found  //请求资源不存在，eg：输入了错误的URL
500 Internal Server Error  //服务器发生不可预期的错误
503 Server Unavailable  //服务器当前不能处理客户端的请求，一段时间后可能恢复正常
参考资料：[请求码][5]

## HTTP请求方法
根据HTTP标准，HTTP请求可以使用多种请求方法。
HTTP1.0定义了三种请求方法：GET,POST和HEAD方法。

HTTP1.1新增了五种请求方法：OPTIONS,PUT,DELETE, TRACE 和 CONNECT 方法。
 > GET     请求指定的页面信息，并返回实体主体。
HEAD      类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头
POST      向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
PUT      从客户端向服务器传送的数据取代指定的文档的内容。
DELETE       请求服务器删除指定的页面。
CONNECT     HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
OPTIONS     允许客户端查看服务器的性能。
TRACE     回显服务器收到的请求，主要用于测试或诊断。

## HTTP请求头字段
### HTTP Request请求头字段
 - Accept:用于告诉服务器，客户机支持的数据类型
 - Accept-Charset:用于告诉服务器，客户机采用的编码
 - Accept-Encoding:用于告诉服务器，客户机支持数据压缩格式
 - Accept-Language:客户机的语言环境
 - Host:客户机通过这个头告诉服务器，想访问的主机名
 - If-Modified-Since:客户机通过这个头告诉服务器，资源的缓存时间
 - Refer:客户机通过这个头告诉服务器，它是从哪个资源访问服务器的(防盗链)
 - User-Agent:客户机通过这个头告诉服务器，客户机的软件环境
 - Cookie:客户机通过这个头向服务器带数据
 - Connection:这个请求完了，是保持连接还是关闭
 - Range:断点下载
    - bytes=n1-n2,传输范围n1到n2字节
    - bytes=n-，传输web资源中第n个字节以后的所有内容
    - bytes=n,传输最后n个字节

### HTTP Response请求头字段
 - Location:这个头配合302状态码使用，用于告诉客户机找谁(location和302实现请求重定向)
 - Server:服务器通过这个头，告诉浏览器服务器的类型
 - Content-Encoding:服务器通过这个头，数据的压缩格式 (相关java知识:GZIPOutputStream,包装流/底层流)
 - Content-Length:服务器通过这个头，告诉浏览器回送数据的长度
 - Content-Type:服务器通过这个头，告诉浏览器回送数据的类型
 - Last-Modified:服务器通过这个头，告诉浏览器当前资源的缓存时间
 - Refresh:服务器通过这个头，告诉浏览器隔多长时间刷新一次
 - Content-Disposition:服务器通过这个头，告诉浏览器以下载方式打开
 - Transfer-Encoding:服务器通过这个头，告诉浏览器数据的传送格式
 - Etag:缓存相关的头部，用于实时性要求高的系统
 - Expires:服务器通过这个头，告诉浏览器把回送的资源缓存多长时间，-1或0则不缓存
 - Cache-Control和Pragma:no-cache,服务器通过这两个头，也是控制浏览器不要缓存数据
 - Connection:断开连接/保持连接
 - Date:当前时间
 - Accept-Ranges:用来说明web服务器是否支持range。支持返回bytes;不支持返回none
 - Content-Range:制定了返回web资源的字节范围，格式：n1-n2/n_total

## GET与POST请求
### GET请求
由于 GET 请求会将请求所携带的参数作为请求URL中的一部分出现，所以请求参数会显示在地址栏。而这就导致了 GET 提交的三点不足。

 - 参数值只能是字符串，而不能是其它类型
 - 可以携带的数据量小
 - 数据安全性低

但 GET 请求有一个很重要的特征：客户端一旦接收到“服务器向GET请求发送的响应”后，浏览器会自动缓存响应。当客户再次进行相同请求提交时将直接读取本地浏览器缓存中数据，而不再向服务端真正发送数据，让用户感觉服务端的响应很快，提升用户体验，减轻了服务器压力。
参考博客：
[HTTP请求 浏览器缓存][6]
[http缓存详解][7]

### POST请求
POST 请求会将请求所携带的数据以请求正文的形式出现，所以与GET方式相比，就显示出了三点长处：
 - 数据类型可以是任意类型，还可以是声音、视频、图片等文件
 - 请求可以携带的数据量大
 - 数据安全性高

POST提交的安全性比GET高，因为能够实现POST提交的方式只有两种：通过表单的POST提交，与通过 AJAX 的 POST提交。其它方式均为GET提交方式。对于一个提供了POST登录页面的系统，若用户试图通过地址栏等方式进行登录，则说明其一定是非法登录。



  [1]: https://www.cnblogs.com/bellkosmos/p/5237146.html
  [2]: https://www.cnblogs.com/aspirant/p/5702338.html
  [3]: http://static.zybuluo.com/xiaocorn/d1878qmergzyjjns3jkjgh8z/image_1clolmsai1n3n1i2iihmva1gcs9.png
  [4]: http://static.zybuluo.com/xiaocorn/ba4lz63tqjjpzxraosiovej0/image_1clom1jbq4rg1v2qlji15j8rn5m.png
  [5]: http://www.runoob.com/http/http-status-codes.html
  [6]: https://www.cnblogs.com/caoheyang911016/p/4110645.html
  [7]: https://blog.csdn.net/hguisu/article/details/8683290